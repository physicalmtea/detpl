/**
 *
 * @file detect_malware_preload.c
 *
 * @desc PRELOAD malware detection is different from using dlopen ()/dlsym () library functions.
 * @desc Some 'Anti bypass' cases are considered. 
 * @desc Such as: do not use glic library function.
 * @desc Such as: using ELF format method of parsing process to get current symbolic address. 
 * @desc Such as: using ELF format method of parsing shared library to get original symbolic address. 
 *
 *
 * @version 0.1
 * @created 2019-09-12
 * @revision 2021-01-19 
 * @revision 2022-09-15 
 *
 * @author sinister E-mail:3350124@mail.qq.com
 *
 */

#define _GNU_SOURCE

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <dlfcn.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <elf.h>
#include <link.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/ptrace.h>
#include <syscall.h>
#include <unistd.h>
#include <errno.h>
#include <dirent.h>
#include <termios.h>
#include <mqueue.h>
#include <sys/ptrace.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <ucontext.h>  
#include <asm/byteorder.h>
#include <dirent.h>
#include <asm/unistd.h>
#include <sys/inotify.h>
#include <gnu/libc-version.h>

#include "detect_malware_preload.h"


//
//
//  Check list of system libraries. 
//  Most of the checks here are syscalls wrapped in libc. 
//  Of course, functions such as 'strCmp' / 'memcpy' can also be added. 
//  However, it should be noted that libc is likely to link symbolic 
//  names optimized for different architectures, 
//  such as: '__strcmp_sse42' This needs to be added accurately in order to detect correctly.
//
//  2019.09.18 added by sinister E-mail:3350124@mail.qq.com
//  
//

static const char *syslib_symbol_table[] = {
	"access", 
	"open",
	"open64",
	"openat",
	"openat64",
	"read",
	"write",
	"mmap",
	"mmap64",
	"mprotect",
	"chmod",
	"chown",
	"readlink",
	"unlink",
	"unlinkat",
	"rmdir",
	"execve",
	"rename",
	"renameat",
	"fopen",
	"fopen64",
 	"fstat",
	"fstat64",
	"lstat",
	"lstat64",
	"lxstat",
	"__lxstat",
	"lxstat64",
	"__lxstat64",
	"fxstat",
	"fxstat64",
	"xstat",
	"__xstat",
	"xstat64",
	"__xstat64",
	"opendir",
	"readdir",
	"readdir64",
	"getpid",
	"connect",
	"accept",
	"ptrace",
	"syscall",
	NULL
};

//
//  Dynamic loading symbol 'libdl.so' Library export. 
//  Detect is required for 'Anti bypass'
//  
//  2019.09.18 added by sinister E-mail:3350124@mail.qq.com
//  
//

static const char *dl_symbol_table[] = {
	"dlopen",
	"dlmopen",
	"dlsym",
	"dlvsym",
	"dladdr",
	"dladdr1",
	"dlclose",
	NULL
};

//
//  'libc.so' library exports a lower level dynamic loading symbol. 
//  Considering 'Anti bypass' it needs detect. 
//  The dynamic symbol loading process is as follows:
//
//	dlsym 
//	  |
//        --dlsym_doit (no exports)
//       	|
//       	-- _dl_sym 
//	
//  NOTES: Of course, there are lower level 'loader' related implementations, 
//         but this is no longer within the scope of 'PRELOAD' or the implementation
//         of this tool.
//
//         'dl_iterate_phdr' detect this function, 
//         because its callback function will also be bypassed. 
//         At least the tool I wrote will do so
//
//  
//  2019.09.18 added by sinister E-mail:3350124@mail.qq.com
//  
//

static const char *__libc_dl_symbol_table[] = {
	"_dl_sym",
	"_dl_vsym",
	"_dl_addr",
	"__libc_dlopen_mode",
	"__libc_dlsym",
	"__libc_dlclose",
	"dl_iterate_phdr",
	NULL
};


#define BUFFER_SIZE (512 * 1024)

//
// 
//  Some of the following string operations are written by me, 
//  and some are copied from the source code in glibc.
//
//  NOTES: What I wrote didn't consider the performance problem.
//  	   They were all the simplest implementations.
//
//  2021.01.06 added by sinister E-mail:3350124@mail.qq.com
//
//

static char *__copy_string(char *dst, const char *src)
{
	char *dstp = dst;

	if (!dstp || !src) {
		return NULL;
	}	

	while (*src != '\0') {
		*(dstp++) = *(src++);
	}

	*dstp = '\0';

	return dstp; 
}

static char *__append_string(char *dest, const char *src)
{
	char *s1 = dest;
	const char *s2 = src;
	register char c;

	if (!dest || !src) {
		return NULL;
	}

	do {
    		c = *s1++;
	} while(c != '\0');

  	s1 -= 2;

  	do {
      		c = *s2++;
      		*++s1 = c;
	} while(c != '\0');

	return dest;
}

static int __length_string(const char *accept)
{
	const char *a;
	int c = 0;

	if (!accept)
		return -1;

	for (a = accept; *a != '\0'; a ++)
		c ++;	

	return c;
}

static void *__copy_memory(void *dst, const void *src, size_t size)
{
	char *dstp = (char *)dst;
	const char *srcp = (const char *)src;
	
	if (!dstp || !srcp || size <= 0)
		return NULL;

	while (size -- > 0)
		*(dstp++) = *(srcp++);

	return dst;
}

static void *__set_memory(void *dst, int c, size_t size)
{
	char *dstp = (char *)dst;

	if (!dstp)
		return NULL;

	while (size -- > 0)
		*(dstp++) = (char)c;

	return dst;
}

static int __match_string(const char *src, const char *dst)
{
	if (!src || !dst)
		return -1;

	while (*src != '\0' && *dst != '\0' && *src == *dst) {
		++ src;
		++ dst;
	}

	if (*src == '\0' && *dst == '\0') 
		return true;
	else
		return false;
}

static char *__match_strstr(const char *phaystack, const char *pneedle)
{
  const unsigned char *haystack, *needle;
  unsigned char b;
  const unsigned char *rneedle;

  if (!phaystack|| !pneedle)
	return NULL;

  haystack = (const unsigned char *) phaystack;

  if ((b = *(needle = (const unsigned char *) pneedle)))
    {
      unsigned char c;
      haystack--;		/* possible ANSI violation */

      {
	unsigned char a;
	do
	  if (!(a = *++haystack))
	    goto ret0;
	while (a != b);
      }

      if (!(c = *++needle))
	goto foundneedle;
      ++needle;
      goto jin;

      for (;;)
	{
	  {
	    unsigned char a;
	    if (0)
	    jin:{
		if ((a = *++haystack) == c)
		  goto crest;
	      }
	    else
	      a = *++haystack;
	    do
	      {
		for (; a != b; a = *++haystack)
		  {
		    if (!a)
		      goto ret0;
		    if ((a = *++haystack) == b)
		      break;
		    if (!a)
		      goto ret0;
		  }
	      }
	    while ((a = *++haystack) != c);
	  }
	crest:
	  {
	    unsigned char a;
	    {
	      const unsigned char *rhaystack;
	      if (*(rhaystack = haystack-- + 1) == (a = *(rneedle = needle)))
		do
		  {
		    if (!a)
		      goto foundneedle;
		    if (*++rhaystack != (a = *++needle))
		      break;
		    if (!a)
		      goto foundneedle;
		  }
		while (*++rhaystack == (a = *++needle));
	      needle = rneedle;	/* took the register-poor aproach */
	    }
	    if (!a)
	      break;
	  }
	}
    }

foundneedle:
  return (char *) haystack;

ret0:
  return 0;
}

char* __string_chr(const char* str, char c)
{
	char* s1 = (char*)str;

	if (str == NULL)
		return NULL;

	while (*s1) {
		if (*s1 == c) 
            		return s1;
		s1++;
	}

	return NULL;
}

char *__string_pbrk (const char *s, const char *accept)
{
	const char *a = accept;

	while (*s != '\0') {
		while (*a != '\0')
		if (*a++ == *s)
			return (char *) s;
		++s;
	}

	return NULL;
}

char * __string_sep(char **stringp, const char *delim)
{
  char *begin, *end;

  begin = *stringp;
  if (begin == NULL)
    return NULL;

  if (delim[0] == '\0' || delim[1] == '\0')
    {
      char ch = delim[0];

      if (ch == '\0')
	end = NULL;
      else
	{
	  if (*begin == ch)
	    end = begin;
	  else if (*begin == '\0')
	    end = NULL;
	  else
	    end = strchr (begin + 1, ch);
	}
    }
  else
    end = __string_pbrk (begin, delim);

  if (end)
    {
      *end++ = '\0';
      *stringp = end;
    }
  else
    *stringp = NULL;

  return begin;
}


#define TOLOWER(x) ((x) | 0x20)
#define isxdigit(c) \
	(isdigit(c) \
	 || ((sizeof(c) == sizeof(char)) \
		 ? (((unsigned char)((((c)) | 0x20) - 'a')) < 6) \
		 : (((unsigned int)((((c)) | 0x20) - 'a')) < 6)))

#define isdigit(c)    ('0' <= (c) && (c) <= '9')

unsigned long __string_toul(const char *cp,char **endp,unsigned int base)
{
    unsigned long result = 0,value;
 
    if (!base) {
        base = 10;
        if (*cp == '0') {
            base = 8;
            cp++;
            if ((TOLOWER(*cp) == 'x') && isxdigit(cp[1])) {
                cp++;
                base = 16;
            }
        }
    } else if (base == 16) {
        if (cp[0] == '0' && TOLOWER(cp[1]) == 'x')
            cp += 2;
    }
    while (isxdigit(*cp) &&
           (value = isdigit(*cp) ? *cp-'0' : TOLOWER(*cp)-'a'+10) < base) {
        result = result*base + value;
        cp++;
    }
    if (endp)
        *endp = (char *)cp;

    return result;
}

int __string_digit(const char *accept)
{
	const char *a;

	if (!accept)
		return -1;

	for (a = accept; *a != '\0'; a ++)
		if (!isdigit(*a))
			return -1;

	return 0;
}

/**
*
* @desc direct call "access" 64bit syscall 
*
* @param Same as syscall parameter
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.3
*
*/

int _x64_access(const char *pathname, int mode)
{
	int rt = -1;
	int sc = __NR_access;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"(rt)
      		:"r"(sc)
    	);
 
	return rt;
}

/**
*
* @desc direct call "open" 64bit syscall 
*
* @param Same as syscall parameter
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.3
*
*/

int _x64_open(const char *pathname, int flags, mode_t mode)
{
	int fd = -1;
	int sc = __NR_open;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"(fd)
      		:"r"(sc)
    	);
 
	return fd;
}

/**
*
* @desc direct call "read" 64bit syscall 
*
* @param Same as syscall parameter
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.3
*
*/

ssize_t _x64_read(int fd, void *buf, size_t count)
{
	ssize_t size = 0;
	int sc = __NR_read;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"(size)
      		:"r"(sc)
    	);
 
	return size;
}

/**
*
* @desc direct call "write" 64bit syscall 
*
* @param Same as syscall parameter
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.3
*
*/

ssize_t _x64_write(int fd, const void *buf, size_t count)
{
	ssize_t size = 0;
	int sc = __NR_write;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"(size)
      		:"r"(sc)
    	);
 
	return size;
}

/**
*
* @desc direct call "close" 64bit syscall 
*
* @param Same as syscall parameter
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.3
*
*/

int _x64_close(int fd)
{
	int rt = -1;
	int sc = __NR_close;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"(rt)
      		:"r"(sc)
    	);
 
	return rt;
}

/**
*
* @desc direct call "stat" 64bit syscall 
*
* @param Same as syscall parameter
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.3
*
*/

int _x64_stat(const char *pathname, struct stat *buf)
{
	int rt = -1;
	int sc = __NR_stat;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"(rt)
      		:"r"(sc)
    	);
 
	return rt;
}

/**
*
* @desc direct call "lstat" 64bit syscall 
*
* @param Same as syscall parameter
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.3
*
*/

int _x64_lstat(const char *pathname, struct stat *buf)
{
	int rt = -1;
	int sc = __NR_lstat;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"(rt)
      		:"r"(sc)
    	);
 
	return rt;
}

/**
*
* @desc direct call "readlink" 64bit syscall 
*
* @param Same as syscall parameter
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.18
*
*/

ssize_t _x64_readlink(const char *path, char *buf, size_t bufsiz)
{
	ssize_t rt = -1;
	int sc = __NR_readlink;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"(rt)
      		:"r"(sc)
    	);
 
	return rt;
}

/**
*
* @desc direct call "mmap" 64bit syscall 
*
* @param Same as syscall parameter
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.3
*
*/

void *_x64_mmap(void *addr, size_t length, int prot, int flags,
                                        int fd, off_t offset)
{
	unsigned long address;
	int sc = __NR_mmap;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"((unsigned long)address)
      		:"r"(sc)
    	);

	return (void *)address; 
}

char *_x64_getcwd(char *buf, size_t size)
{
	char *result;
	int sc = __NR_getcwd;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"(result)
      		:"r"(sc)
    	);

	return result;
}

int _x64_chdir(const char *path)
{
	int ret = -1;
	int sc = __NR_chdir;

	__asm__ __volatile__(
		"mov %1, %%eax;"   // Move syscall number to eax
		"syscall;"         // Make the syscall
		"mov %%eax, %0;"   // Move the return value into ret
		:"=r"(ret)
		:"r"(sc), "r"(path)
	);

	return ret;
}



/**
*
* @desc direct call "getdents" 64bit syscall 
*
* @param Same as syscall parameter
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.14
*
*/

int _x64_getdents(unsigned int fd, struct linux_dirent *dirp, unsigned count)
{
	int rt = -1;
	int sc = __NR_getdents;

	__asm__ __volatile__(
      		"mov %1, %%eax;"
      		"syscall;"
      		"mov %%eax, %0;"
      		:"=m"(rt)
      		:"r"(sc)
    	);

	return rt; 
}

//
//
//  The 'vprintf' function code comes from the network, the author is unknown. 
//  I modified part of the code to use syscall directly and output to file
//  It is also implemented for the need of 'Anti bypass'
//
//  2021.01.16 added by sinister E-mail:3350124@mail.qq.com 
//
//

unsigned char hex_tab[]={'0','1','2','3','4','5','6','7',\
			'8','9','a','b','c','d','e','f'};

static int outc(int fd, int c) 
{
	if (fd < 0)
		return -1;

	_x64_write(fd, &c, 1);
	return 0;
}

static int outs(int fd, const char *s)
{
	if (fd < 0 || !s)
		return -1;

	while (*s != '\0')	
		_x64_write(fd, &*s++, 1);

	return 0;
}

static int out_num(int fd, long n, int base, char lead, int maxwidth)            
{
	unsigned long m = 0;
	char buf[64], *s = buf + sizeof(buf);
	int count = 0;

	*--s = '\0';   
	
	if (n < 0)
		m = -n;
	else
		m = n;
	
	do {
		*--s = hex_tab[ m % base];
		count++;

	} while((m /= base) != 0); 

	if (n < 0)
		*--s = '-'; 
	
	return outs(fd, s);
}

static int vprintf_nouselib(int fd, const char *fmt, va_list ap) 
{
	char lead=' ';
	int  maxwidth = 0;
	
	 for(; *fmt != '\0'; fmt++) {
		if (*fmt != '%') {
			outc(fd, *fmt);            
			continue;       		
		}

		fmt++;
		if(*fmt == '0'){         
			lead = '0';
			fmt++;	
		}

		while(*fmt >= '0' && *fmt <= '9'){
			maxwidth *=10;
			maxwidth += (*fmt - '0');
			fmt++;
		}
		
		switch (*fmt) {          
			case 'd': 
				out_num(fd, va_arg(ap, int), 10, lead, maxwidth); 
				break;
			case 'o': 
				out_num(fd, va_arg(ap, unsigned int), 8, lead, maxwidth); 
				break;				
			case 'u': 
				out_num(fd, va_arg(ap, unsigned int), 10, lead, maxwidth);
				break;

			//
			// Added '%lx' format support
			//
			// 2021.01.16 added by sinister 3350124@mail.qq.com
			//
		
			case 'l':
				if (fmt[1] == 'x') {
					out_num(fd, va_arg(ap, unsigned long), 16, lead, maxwidth);
					fmt ++;
				}

				break;

			//
			// Added '%p' format support
			//
			// 2021.01.16 added by sinister 3350124@mail.qq.com
			//

			case 'p':
				outs(fd, "0x");
				out_num(fd, va_arg(ap, unsigned long), 16, lead, maxwidth);
				break;
			case 'x':
				out_num(fd, va_arg(ap, unsigned int), 16, lead, maxwidth);
				break;
			case 'c': 
				outc(fd, va_arg(ap, int)); 
				break;		
			case 's': 
				outs(fd, va_arg(ap, char *)); 
				break;		  		
				
			default:  
				outc(fd, *fmt);
				break;
		}
	}

	return 0;
}

void fprintf_nouselib(int fd, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vprintf_nouselib(fd, fmt, ap);	
	va_end(ap);
}


/**
*
* @desc Detection of glibc internal dynamic loader hook structure
* @desc Instead of using 'dladdr' to get the symbol name, 
* 	we directly parse 'procfs' for anti bypass consideration.
*
* @retval Number of symbols hooked 
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.18
*
*/

static int dl_internal_hook_struct_check(void)
{
	char libc_name[256] = {0};

	int rc;
	int found_count = 0;

        fprintf_nouselib(2, "internal hook structure checking...\n");

	if (get_glibc_version() >= (unsigned int)2025)
		return found_count;

	if (nouselib)
 		rc = elf_so_dynamic_nouselib("libc-");
	else
		dl_iterate_phdr(elf_so_dynamic_callback, "libc.so.6");
	elf_symbol_segment();

	//
	//
	// The "__libc_dlsym" function starts to determine whether the "_dl_open_hook" structure is NULL, and if not, 
	// jumps to the structure to execute the hook function. This structure is the internal structure of glibc, 
	// which is different from using PRELOAD method to hook "__libc_dlsym". We need to check this address in order to 
	// find a more covert way to hook "__libc_dlopen_mode" & "__libc_dlsym" and other functions. 
	//
	// (gdb) disas __libc_dlsym
	// Dump of assembler code for function __libc_dlsym:
	// 0x0000003b8d502970 <__libc_dlsym+0>:    sub    $0x48,%rsp
	// 0x0000003b8d502974 <__libc_dlsym+4>:    mov    2408661(%rip),%rax        # 0x3b8d74ea50 <_dl_open_hook>
	// 0x0000003b8d50297b <__libc_dlsym+11>:   mov    %rdi,(%rsp)
	// 0x0000003b8d50297f <__libc_dlsym+15>:   mov    %rsi,0x8(%rsp)
	// 0x0000003b8d502984 <__libc_dlsym+20>:   test   %rax,%rax
	// 0x0000003b8d502987 <__libc_dlsym+23>:   jne    0x3b8d5029f4 <__libc_dlsym+132>
	// 
	// (gdb) x/2gx 0x3b8d74ea50 
	// 0x3b8d74ea50 <_dl_open_hook>:   0x0000000000000000      0x0000000000000001
	//
	// 2019.9.21 added by sinister E-mail:3350124@mail.qq.com
	//

	void *_dl_open_hook_ptr = elf_serach_symbol("_dl_open_hook", so_symbol_table, so_string_table);
	if (!_dl_open_hook_ptr)
		return -1;

	struct dl_open_hook *internal_open_hook_struct = (struct dl_open_hook *)*((uint64_t *)(uint64_t)_dl_open_hook_ptr);

	if (internal_open_hook_struct != NULL) {

		if (nouselib)
			rc = dlname_from_segment_nouselib((void *)internal_open_hook_struct, libc_name);
		else
			rc = _dlname_from_segment_address((void *)internal_open_hook_struct, libc_name);
		if (rc < 0) {
			if (nouselib)
				__copy_string(libc_name, "Unknow libc name");
			else
				strcpy(libc_name, "Unknow libc name");
		}
		
		if (nouselib) {
			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"dl_open_hook->__libc_dlopen_mode",
					(uint64_t)internal_open_hook_struct->__libc_dlopen_mode,
					libc_name
					);

			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"dl_open_hook->__libc_dlsym",
					(uint64_t)internal_open_hook_struct->__libc_dlsym,
					libc_name
					);

			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"dl_open_hook->__libc_dlclose",
					(uint64_t)internal_open_hook_struct->__libc_dlclose,
					libc_name
					);
		} else {
			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
				"dl_open_hook->__libc_dlopen_mode",
				(uint64_t)internal_open_hook_struct->__libc_dlopen_mode,
				libc_name
				);

			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
				"dl_open_hook->__libc_dlsym",
				(uint64_t)internal_open_hook_struct->__libc_dlsym,
				libc_name
				);

			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
				"dl_open_hook->__libc_dlclose",
				(uint64_t)internal_open_hook_struct->__libc_dlclose,
				libc_name
				);
		}

		found_count = 3;
	} else {

		if (nouselib) {
			fprintf_nouselib(STDOUT_FILENO, "[+] _dl_open_hook checking...done\n");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "dl_open_hook->__libc_dlopen_mode");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "dl_open_hook->__libc_dlsym");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "dl_open_hook->__libc_dlclose");
		} else {
			fprintf(stdout, "[+] _dl_open_hook checking...done\n");
			fprintf(stdout, "[+] %s checking...done\n", "dl_open_hook->__libc_dlopen_mode");
			fprintf(stdout, "[+] %s checking...done\n", "dl_open_hook->__libc_dlsym");
			fprintf(stdout, "[+] %s checking...done\n", "dl_open_hook->__libc_dlclose");
		}
	}

	if (nouselib)
		elf_so_dynamic_nouselib("libdl-");
	else
		dl_iterate_phdr(elf_so_dynamic_callback, "libdl.so.2");
	elf_symbol_segment();

	//
	//
	// The "dlsym" function starts to determine whether the "_dlfcn_hook" structure is NULL, and if not, 
	// jumps to the structure to execute the hook function. This structure is the internal structure of glibc, 
	// which is different from using PRELOAD method to hook "dlsym". We need to check this address in order to 
	// find a more covert way to hook "dlopen" & "dlsym" & "dlvsym" and other functions. 
	//
	// (gdb) disas dlsym
	// Dump of assembler code for function dlsym:
	// 0x0000003b8dc01070 <dlsym+0>:   push   %rbp
	// 0x0000003b8dc01071 <dlsym+1>:   push   %rbx
	// 0x0000003b8dc01072 <dlsym+2>:   sub    $0x28,%rsp
	// 0x0000003b8dc01076 <dlsym+6>:   mov    2105379(%rip),%rax        # 0x3b8de030a0 <_dlfcn_hook>
	// 0x0000003b8dc0107d <dlsym+13>:  test   %rax,%rax
	// 0x0000003b8dc01080 <dlsym+16>:  jne    0x3b8dc010dc <dlsym+108>
	//
	// (gdb) x/4gx 0x3b8de030a0 
	// 0x3b8de030a0 <_dlfcn_hook>:     0x0000000000000000      0x0000000000000000
	// 0x3b8de030b0 <_dlfcn_hook+16>:  0x0000000000000000      0x0000000000000000
	//
	// 2019.9.21 added by sinister E-mail:3350124@mail.qq.com
	//

	void *_dlfcn_hook_ptr = elf_serach_symbol("_dlfcn_hook", so_symbol_table, so_string_table);
	struct dlfcn_hook *internal_dlfcn_hook_struct = (struct dlfcn_hook *)*((uint64_t *)(uint64_t)_dlfcn_hook_ptr);
	if (internal_dlfcn_hook_struct != NULL) {

		if (nouselib)
			rc = dlname_from_segment_nouselib((void *)internal_open_hook_struct, libc_name);
		else
			rc = _dlname_from_segment_address((void *)internal_open_hook_struct, libc_name);
		if (rc < 0) {
			if (nouselib)
				__copy_string(libc_name, "Unknow libc name");
			else 
				strcpy(libc_name, "Unknow libc name");
		}
		
		if (nouselib) {
			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlopen",
					(uint64_t)internal_dlfcn_hook_struct->dlopen,
					libc_name
					);

			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlclose",
					(uint64_t)internal_dlfcn_hook_struct->dlclose,
					libc_name
					);

			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlsym",
					(uint64_t)internal_dlfcn_hook_struct->dlsym,
					libc_name
					);

			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlvsym",
					(uint64_t)internal_dlfcn_hook_struct->dlvsym,
					libc_name
					);

			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlerror",
					(uint64_t)internal_dlfcn_hook_struct->dlerror,
					libc_name
					);

			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dladdr",
					(uint64_t)internal_dlfcn_hook_struct->dladdr,
					libc_name
					);

			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dladdr1",
					(uint64_t)internal_dlfcn_hook_struct->dladdr1,
					libc_name
					);

			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlinfo",
					(uint64_t)internal_dlfcn_hook_struct->dlinfo,
					libc_name
					);
	
			fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlmopen",
					(uint64_t)internal_dlfcn_hook_struct->dlmopen,
					libc_name
					);
		} else {
			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlopen",
					(uint64_t)internal_dlfcn_hook_struct->dlopen,
					libc_name
					);

			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlclose",
					(uint64_t)internal_dlfcn_hook_struct->dlclose,
					libc_name
					);

			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlsym",
					(uint64_t)internal_dlfcn_hook_struct->dlsym,
					libc_name
					);

			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlvsym",
					(uint64_t)internal_dlfcn_hook_struct->dlvsym,
					libc_name
					);

			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlerror",
					(uint64_t)internal_dlfcn_hook_struct->dlerror,
					libc_name
					);

			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dladdr",
					(uint64_t)internal_dlfcn_hook_struct->dladdr,
					libc_name
					);

			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dladdr1",
					(uint64_t)internal_dlfcn_hook_struct->dladdr1,
					libc_name
					);

			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlinfo",
					(uint64_t)internal_dlfcn_hook_struct->dlinfo,
					libc_name
					);
	
			fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s)!!!\n",
					"_dlfcn_hook->dlmopen",
					(uint64_t)internal_dlfcn_hook_struct->dlmopen,
					libc_name
					);
		}

		found_count = found_count + 9;

	} else {

		if (nouselib) {
			fprintf_nouselib(STDOUT_FILENO, "[+] _dlfcn_hook checking...done\n");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "_dlfcn_hook->dlopen");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "_dlfcn_hook->dlclose");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "_dlfcn_hook->dlsym");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "_dlfcn_hook->dlvsym");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "_dlfcn_hook->dlerror");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "_dlfcn_hook->dladdr");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "_dlfcn_hook->dladdr1");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "_dlfcn_hook->dlinfo");
			fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", "_dlfcn_hook->dlmopen");
		} else {
			fprintf(stdout, "[+] _dlfcn_hook checking...done\n");
			fprintf(stdout, "[+] %s checking...done\n", "_dlfcn_hook->dlopen");
			fprintf(stdout, "[+] %s checking...done\n", "_dlfcn_hook->dlclose");
			fprintf(stdout, "[+] %s checking...done\n", "_dlfcn_hook->dlsym");
			fprintf(stdout, "[+] %s checking...done\n", "_dlfcn_hook->dlvsym");
			fprintf(stdout, "[+] %s checking...done\n", "_dlfcn_hook->dlerror");
			fprintf(stdout, "[+] %s checking...done\n", "_dlfcn_hook->dladdr");
			fprintf(stdout, "[+] %s checking...done\n", "_dlfcn_hook->dladdr1");
			fprintf(stdout, "[+] %s checking...done\n", "_dlfcn_hook->dlinfo");
			fprintf(stdout, "[+] %s checking...done\n", "_dlfcn_hook->dlmopen");
		}
	}

	return found_count;
}

/**
*
* @desc Detection dynamic loader PRELOAD hook 
* @desc Instead of using 'dladdr' to get the symbol name, 
* 	we directly parse 'procfs' for anti bypass consideration.
*
* @retval Number of symbols hooked 
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.18
*
*/

static int dl_symbol_check(void)
{
	void *elf_symbol_address;
	void *got_entry_address;
	const char **symbol_ptr;

	char libc_name[256] = {0};

	int rc;
	int found_count = 0;

        fprintf_nouselib(2, "dynamic loader symbol checking...\n");

	if (nouselib)
		elf_process_dynamic_nouselib();
	else
		dl_iterate_phdr(elf_process_dynamic_callback, NULL);
	elf_process_segment();

	if (get_glibc_version() < (unsigned int)2025) { 
		if (nouselib)
			elf_so_dynamic_nouselib("libdl-");
		else
			dl_iterate_phdr(elf_so_dynamic_callback, "libdl.so.2");
	} else {
		if (nouselib)
			elf_so_dynamic_nouselib("libc.so.6");
		else
			dl_iterate_phdr(elf_so_dynamic_callback, "libc.so.6");
	}

	elf_symbol_segment();

	for (symbol_ptr = dl_symbol_table; *symbol_ptr; symbol_ptr ++) {

		got_entry_address = (void *)elf_serach_process_got_symbol(*symbol_ptr, process_symbol_table, process_string_table);
		elf_symbol_address = elf_serach_symbol(*symbol_ptr, so_symbol_table, so_string_table);

		if (elf_symbol_address != got_entry_address) {

			if (nouselib)
				rc = dlname_from_segment_nouselib((void *)got_entry_address, libc_name);
			else
				rc = _dlname_from_segment_address((void *)got_entry_address, libc_name);
			if (rc < 0) {
				if (nouselib)
					__copy_string(libc_name, "Unknow libc name");
				else
					strcpy(libc_name, "Unknow libc name");
			}
			
			if (nouselib)
				fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s) <-> real address 0x%lx !!!\n",
							 *symbol_ptr,
							 (uint64_t)got_entry_address,
							 libc_name,
							 (uint64_t)elf_symbol_address
							);
			else

				fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s) <-> real address 0x%lx !!!\n",
							 *symbol_ptr,
							 (uint64_t)got_entry_address,
							 libc_name,
							 (uint64_t)elf_symbol_address
							);

			found_count ++;
		} else {
			if (nouselib)
				fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", *symbol_ptr);
			else
				fprintf(stdout, "[+] %s checking...done\n", *symbol_ptr);
		}
	}



	if (get_glibc_version() < (unsigned int)2025) { 
		if(nouselib)
			elf_so_dynamic_nouselib("libc-");
		else
			dl_iterate_phdr(elf_so_dynamic_callback, "libc.so.6");
	} else {
		if(nouselib)
			elf_so_dynamic_nouselib("libc.so.6");
		else
			dl_iterate_phdr(elf_so_dynamic_callback, "libc.so.6");

	}

	elf_symbol_segment();

	for (symbol_ptr = __libc_dl_symbol_table; *symbol_ptr; symbol_ptr ++) {

		got_entry_address = (void *)elf_serach_process_got_symbol(*symbol_ptr, process_symbol_table, process_string_table);
		elf_symbol_address = elf_serach_symbol(*symbol_ptr, so_symbol_table, so_string_table);

		if (elf_symbol_address != got_entry_address) {
			
			if (nouselib)
				rc = dlname_from_segment_nouselib((void *)got_entry_address, libc_name);
			else
				rc = _dlname_from_segment_address((void *)got_entry_address, libc_name);
			if (rc < 0) {
				if (nouselib)
					__copy_string(libc_name, "Unknow libc name");
				else
					strcpy(libc_name, "Unknow libc name");
			}

			if (nouselib)
				fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s) <-> real address 0x%lx !!!\n",
							 *symbol_ptr,
							 (uint64_t)got_entry_address,
							 libc_name,
							 (uint64_t)elf_symbol_address
							);

			else
				fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s) <-> real address 0x%lx !!!\n",
							 *symbol_ptr,
							 (uint64_t)got_entry_address,
							 libc_name,
							 (uint64_t)elf_symbol_address
							);

	
			found_count ++;
		} else {
			if (nouselib)
				fprintf_nouselib(STDOUT_FILENO, "[+] %s checking...done\n", *symbol_ptr);
			else
				fprintf(stdout, "[+] %s checking...done\n", *symbol_ptr);
		}
	}
	
	return found_count;
}

/**
*
* @desc Detection libc symbols PRELOAD hook 
* @desc Instead of using 'dladdr' to get the symbol name, 
* 	we directly parse 'procfs' for anti bypass consideration.
*
* @retval Number of symbols hooked 
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.18
*
*/

static int syslib_symbol_check(void)
{
	void *elf_symbol_address;
	void *got_entry_address;

	char libc_name[256] = {0};
	unsigned long ul_glibc_version = 0;

	int rc;
	int found_count = 0;
	const char **symbol_ptr;

        fprintf_nouselib(2, "system library symbol checking...\n");

	if (nouselib)
		elf_process_dynamic_nouselib();
	else
		dl_iterate_phdr(elf_process_dynamic_callback, NULL);
	elf_process_segment();


	if (nouselib) {
		ul_glibc_version = get_glibc_version();
		if (ul_glibc_version < (unsigned long)2025)
			rc = elf_so_dynamic_nouselib("libc-");
		else 
			rc = elf_so_dynamic_nouselib("libc.so.6");

		if (rc < 0)
			return rc;			
	} 
	else
		dl_iterate_phdr(elf_so_dynamic_callback, "libc.so.6");
	elf_symbol_segment();

	for (symbol_ptr = syslib_symbol_table; *symbol_ptr; symbol_ptr ++) {

		elf_symbol_address = (void *)elf_serach_symbol(*symbol_ptr, so_symbol_table, so_string_table);
		got_entry_address = (void *)elf_serach_process_got_symbol(*symbol_ptr, process_symbol_table, process_string_table);

		if (elf_symbol_address != got_entry_address) {

			if (nouselib)
				rc = dlname_from_segment_nouselib((void *)got_entry_address, libc_name);
			else
				rc = _dlname_from_segment_address((void *)got_entry_address, libc_name);
			if (rc < 0) {
				if (nouselib)
					__copy_string(libc_name, "Unknow libc name");
				else
					strcpy(libc_name, "Unknow libc name");
			}

			if (nouselib)
				fprintf_nouselib(STDERR_FILENO, "[+] %s checking...!!!Found hooked address 0x%lx (%s) <-> real address 0x%lx !!!\n",
						 *symbol_ptr,
						 (uint64_t)got_entry_address,
						 libc_name,
						 (uint64_t)elf_symbol_address
						);
			else
				fprintf(stderr, "[+] %s checking...!!!Found hooked address 0x%lx (%s) <-> real address 0x%lx !!!\n",
						 *symbol_ptr,
						 (uint64_t)got_entry_address,
						 libc_name,
						 (uint64_t)elf_symbol_address
						);

			found_count ++;
		} else {
			if (nouselib)
				fprintf_nouselib(STDERR_FILENO, "[+] %s checking...done\n", *symbol_ptr);
			else
				fprintf(stderr, "[+] %s checking...done\n", *symbol_ptr);
				
		}
	}

	return found_count;
}

/**
*
* @desc Directly serach locate symbols from ELF format 
*
* @param [IN] serach symbol name 
* @param [IN] symbol table 
* @param [IN] string table
*
* @retval symbol address 
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.13
*
*/

uint64_t *elf_serach_symbol(const char *name, ElfW(Sym) *symbol_table, const char *string_table)
{
	uint64_t symbol_index = 0;
	uint64_t symbol_max_size = 0;
	uint64_t *symbol_address = NULL;
	const char *symbol_name;


	if (!symbol_table || !string_table || !name) {
		return symbol_address;
	}

	//
	// This assumes that the symbol segment is adjacent to the string table
	// (string_table - symbol_table) Calculate the number of symbols
	//
	// 2019.9.12 added by sinister E-mail:3350124@mail.qq.com
	//

	symbol_max_size = (((uint64_t)string_table - (uint64_t)symbol_table)) / sizeof(ElfW(Sym));

	for (symbol_index = 0; 
		symbol_index < symbol_max_size;
		symbol_index ++) {

		if (symbol_table[symbol_index].st_name <= 0) {
			continue;
		}		

		symbol_name = string_table + symbol_table[symbol_index].st_name;
		if (symbol_name) {
			if (true == __match_string(symbol_name, name)) { 

#ifdef DEBUG
				fprintf(stdout, "call %s(0x%lx)\n", 
							symbol_name,
							symbol_table[symbol_index].st_value	
							);
#endif
	
				symbol_address = (uint64_t *)symbol_table[symbol_index].st_value;

				if (module_base_address) {
					symbol_address = (uint64_t *)((uint64_t)module_base_address + (uint64_t)symbol_address);
				}

				break;
			}

		}
	}

	return symbol_address;
}

/**
*
* @desc Directly serach process import symbols from ELF format 
*
* @param [IN] serach symbol name 
* @param [IN] symbol table 
* @param [IN] string table
*
* @retval symbol address 
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.13
*
*/

uint64_t *elf_serach_process_got_symbol(const char *name, ElfW(Sym) *symbol_table, const char *string_table)
{
	ElfW(Rela) *rela_entry;
	ElfW(Xword) relocation_count;
	ElfW(Xword) rel_index;

	ElfW(Sym) *symbol_entry;
	uint64_t symbol_index;
	ElfW(Word) string_index;
	const char *symbol_name;

	uint64_t *symbol_address = NULL;


	if (!process_relocation_table || !name) {
		goto end;
	}

	relocation_count = process_relocation_segment_max_size / process_relocation_segment_entry_size;

	for (rel_index = 0; 
		rel_index < relocation_count;
		rel_index ++) {
	 		
		rela_entry = &process_relocation_table[rel_index];

		symbol_index = ELF64_R_SYM(rela_entry->r_info);
		if (symbol_index <= 0) {
			goto end;
		}

		symbol_entry = &symbol_table[symbol_index];
		string_index = symbol_entry->st_name;
		if (string_index <= 0) {
			goto end;
		}

		symbol_name = &string_table[string_index];
		if (symbol_name) {
			if (true == __match_string(symbol_name, name)) { 

#ifdef DEBUG
				fprintf(stdout, "call %s() [rel index:0x%lx GOT offset:0x%lx]\n", 
					symbol_name,
					symbol_index,
					rela_entry->r_offset
					);
#endif
				uint64_t *Got_entry;
				if (process_module_base_address) {
					Got_entry = (uint64_t *)((uint64_t)process_module_base_address + 
										rela_entry->r_offset);
					symbol_address = (uint64_t *)*Got_entry;
				} else {
					Got_entry = (uint64_t *)(uint64_t)rela_entry->r_offset;
					symbol_address = (uint64_t *)*Got_entry;
				}
				
				break;

			}
		}

	}

end:
	return symbol_address;
}

/**
*
* @desc Get symbol tables and string tables from shared object DYNAMIC segment
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.13
*
*/

void elf_symbol_segment(void)
{
	ElfW(Dyn) *dyn_segment;; 

	if (!shared_object_dynamic_segment) {
		return;
	}

	for (dyn_segment = shared_object_dynamic_segment;
		dyn_segment->d_tag != DT_NULL;
		++ dyn_segment) {

		if (dyn_segment->d_tag == DT_SYMTAB) {
			so_symbol_table = (ElfW(Sym) *)dyn_segment->d_un.d_ptr;
#ifdef DEBUG
			fprintf(stdout, "symbol table address: 0x%lx\n", so_symbol_table);
#endif
			continue;
		}

       		if (dyn_segment->d_tag == DT_STRTAB) {
			so_string_table = (const char *)dyn_segment->d_un.d_ptr;
#ifdef DEBUG
			fprintf(stdout, "string table address: 0x%lx\n", so_string_table);
#endif
			continue;
		}
	}
}

/**
*
* @desc Get segments of information from process DYNAMIC segment
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.13
*
*/

void elf_process_segment(void)
{
	ElfW(Dyn) *dyn_segment;

	if (!process_dynamic_segment) {
		return;
	}

	for (dyn_segment = process_dynamic_segment;
		dyn_segment->d_tag != DT_NULL;
		++ dyn_segment) {

       		if (dyn_segment->d_tag == DT_SYMTAB) {
			process_symbol_table = (ElfW(Sym) *)dyn_segment->d_un.d_ptr;
#ifdef DEBUG
			fprintf(stdout, "symbol table address: 0x%lx\n", (uint64_t)process_symbol_table);
#endif
			continue;
		}

       		if (dyn_segment->d_tag == DT_STRTAB) {
			process_string_table = (const char *)dyn_segment->d_un.d_ptr;
#ifdef DEBUG
			fprintf(stdout, "string table address: 0x%lx\n", (uint64_t)process_string_table);
#endif
			continue;
		}

       		if (dyn_segment->d_tag == DT_JMPREL) {
			process_relocation_table = (ElfW(Rela) *)dyn_segment->d_un.d_ptr;
#ifdef DEBUG
			fprintf(stdout, "relocation table address (JMPREL): 0x%lx\n", (uint64_t)process_relocation_table);
#endif
			continue;
		}

		if (dyn_segment->d_tag == DT_PLTRELSZ) {
			process_relocation_segment_max_size = dyn_segment->d_un.d_val;
#ifdef DEBUG
			fprintf(stdout, "PLTRELSZ relocation segment max size: %u(bytes)\n", (unsigned int)process_relocation_segment_max_size);
#endif 
			continue;
		}

		//
		// 64bit linux used RELA structure
		//

		if (dyn_segment->d_tag == DT_RELAENT) {
			process_relocation_segment_entry_size = dyn_segment->d_un.d_val;
#ifdef DEBUG
			fprintf(stdout, "relocation segment entry size: %u(bytes)\n", process_relocation_segment_entry_size);
#endif
			continue;
		}

		if (dyn_segment->d_tag == DT_PLTGOT) {
			process_plt_got_segment = (ElfW(Addr) *)dyn_segment->d_un.d_ptr;
			if (process_plt_got_segment) {
				lm = (struct link_map *)*(process_plt_got_segment + _GOT_LINKMAP_OFFSET);
			}
#ifdef DEBUG
			fprintf(stdout, "plt_got_segment address: 0x%lx\nlink_map address:0x%lx\n", 
				process_plt_got_segment, lm);
#endif

			continue;
		}

	}
}

/**
*
* @desc Get the DYNAMIC segment address from the specified shared object
*
* @param [IN] program header information
* @param [IN] dpi structure size 
* @param [IN] pecified shared library name
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.13
*
*/

int elf_so_dynamic_callback(struct dl_phdr_info *dpi, size_t size, void *data)
{
	const ElfW(Phdr) *p_hdr;
	int idx;

	const char *libc_name = (const char *)data;
		
	for (idx = 0; idx < dpi->dlpi_phnum; idx ++) {
		p_hdr = &(dpi->dlpi_phdr[idx]);

		if (libc_name) {
			if (!__match_strstr(dpi->dlpi_name, libc_name)) {
				continue;
			}
		}

		if (p_hdr->p_type != PT_DYNAMIC) {
			continue;
		}


		//
		// Shared libraries may be relatively offset. 
		// This field effectively represents the module base address.
		//
		// added by sinister 3350124@mail.qq.com
		// 2019.09.14
		//
	
		if (dpi->dlpi_addr) {
			module_base_address = (ElfW(Addr) *)dpi->dlpi_addr;
#ifdef DEBUG
			fprintf(stdout, "module base address:0x%lx\n", (uint64_t)module_base_address);
#endif
		}

		shared_object_dynamic_segment = (ElfW(Dyn) *)(dpi->dlpi_addr + p_hdr->p_vaddr);
	}

	return 0;
}

/**
*
* @desc Get the DYNAMIC segment address from the current process
*
* @param [IN] program header information
* @param [IN] dpi structure size 
* @param [IN] NULL 
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.13
*
*/

int elf_process_dynamic_callback(struct dl_phdr_info *dpi, size_t size, void *data)
{
	const ElfW(Phdr) *p_hdr;
	int idx;
	
	if (found_process_dyn) {
		return 0;
	}
	
	for (idx = 0; idx < dpi->dlpi_phnum; idx ++) {
		p_hdr = &(dpi->dlpi_phdr[idx]);
	
		//
		// Main process dynamic segment "dpi->dlpi_name" field has no content 
		//
		// 2019.9.14 added by sinister E-mail:3350124@mail.qq.com
		//
	
		if (*dpi->dlpi_name != '\0') {
			continue;
		}

		if (p_hdr->p_type != PT_DYNAMIC) {
			continue;
		}

		//
		// Shared libraries may be relatively offset. 
		// This field effectively represents the module base address.
		//
		// added by sinister 3350124@mail.qq.com
		// 2019.09.14
		//
	
		if (dpi->dlpi_addr) {
			process_module_base_address = (ElfW(Addr) *)dpi->dlpi_addr;
#ifdef DEBUG
			fprintf(stdout, "module base address:0x%lx\n", (uint64_t)module_base_address);
#endif
		}

		if (process_dynamic_segment == NULL) {
			process_dynamic_segment = (ElfW(Dyn) *)(dpi->dlpi_addr + p_hdr->p_vaddr);
			found_process_dyn = true;
		}

		break;
	}

	return 0;
}

/**
*
* @desc Get the DYNAMIC segment address from the current process
* @desc Do not rely on library functions, directly resolve 'ELF' format
*
* @author sinister 3350124@mail.qq.com
* @date 2021.01.6
*
*/

int elf_process_dynamic_nouselib(void)
{
	unsigned long map_base;
	ElfW(Ehdr) *e_hdr;
	ElfW(Phdr) *p_hdr;
	unsigned char *phdr_buf;

	int rt = -1;
	int idx;

	if (found_process_dyn) {
		return 0;
	}

	rt = dladdress_from_segment_nouselib(NULL, &map_base);
	if (rt <= 0)
		return rt;

	e_hdr = (ElfW(Ehdr) *)map_base;
	if( e_hdr->e_ident[EI_MAG0] != 0x7f
    		|| e_hdr->e_ident[EI_MAG1] != 'E'
    		|| e_hdr->e_ident[EI_MAG2] != 'L'
    		|| e_hdr->e_ident[EI_MAG3] != 'F'
    		|| e_hdr->e_ident[EI_VERSION] != EV_CURRENT
    		|| e_hdr->e_version != EV_CURRENT) {
   
#ifdef DEBUG 
        	fprintf_nouselib(STDOUT_FILENO, "File type not supported\n");
#endif
		return rt;
	}

	if (e_hdr->e_phnum < 0)
		return rt;
	
	if (sizeof(ElfW(Phdr)) != e_hdr->e_phentsize)
		return rt;

	phdr_buf = (unsigned char *)((unsigned long)e_hdr + e_hdr->e_phoff);
	if (!phdr_buf)
		return rt;

	for (idx = 0; idx < e_hdr->e_phnum; idx ++) { 

		p_hdr = (ElfW(Phdr) *)&phdr_buf[idx * e_hdr->e_phentsize];
		if (!p_hdr) 
			continue;	

		if (p_hdr->p_type != PT_DYNAMIC)
			continue;

		//
		// In some higher version environment compiling (such as: Ubuntu) 
		// The new 'ALSR' will also randomize process base address.
		// executable file will also bring 'DT_DYN' flag, 
		// which needs to add the process base address to get the correct 
		// 'dynamic segment' address
		//
		// 2021.01.22 added by sinister E-mail:3350124@mail.qq.com
		//

		if (e_hdr->e_type == ET_DYN) {

			process_module_base_address = (ElfW(Addr) *)map_base; 
			process_dynamic_segment = (ElfW(Dyn) *)(map_base + p_hdr->p_vaddr);

		} else if (e_hdr->e_type == ET_EXEC) {

			process_dynamic_segment = (ElfW(Dyn) *)(p_hdr->p_vaddr);
		}

		if (process_dynamic_segment) {
			found_process_dyn = true;
#ifdef DEBUG
			fprintf_nouselib(STDOUT_FILENO, "dynamic segment 0x%x\n", (unsigned long)dynamic_segment);
#endif
			break;
		}
	}

	rt = 0;

	return rt;
}

/**
*
* @desc Get the DYNAMIC segment address from the specified shared object
* @desc Do not rely on library functions, directly resolve 'ELF' format
*
* @author sinister 3350124@mail.qq.com
* @date 2021.01.6
*
*/

int elf_so_dynamic_nouselib(const char *libc_name)
{
	unsigned long map_base;
	ElfW(Ehdr) *e_hdr;
	ElfW(Phdr) *p_hdr;
	unsigned char *phdr_buf;

	int rt = -1;
	int idx;

	if (!libc_name)
		return rt;

	rt = dladdress_from_segment_nouselib(libc_name, &map_base);
	if (rt < 0)
		return rt;

	e_hdr = (ElfW(Ehdr) *)map_base;
	if( e_hdr->e_ident[EI_MAG0] != 0x7f
    		|| e_hdr->e_ident[EI_MAG1] != 'E'
    		|| e_hdr->e_ident[EI_MAG2] != 'L'
    		|| e_hdr->e_ident[EI_MAG3] != 'F'
    		|| e_hdr->e_ident[EI_VERSION] != EV_CURRENT
    		|| e_hdr->e_version != EV_CURRENT) {

#ifdef DEBUG
        	fprintf_nouselib(2, "File type not supported\n");
#endif
		return rt;
	}

	if (e_hdr->e_phnum < 0)
		return rt;
	
	if (sizeof(ElfW(Phdr)) != e_hdr->e_phentsize)
		return rt;

	phdr_buf = (unsigned char *)((unsigned long)e_hdr + e_hdr->e_phoff);
	if (!phdr_buf)
		return rt;

	for (idx = 0; idx < e_hdr->e_phnum; idx ++) { 

		p_hdr = (ElfW(Phdr) *)&phdr_buf[idx * e_hdr->e_phentsize];
		if (!p_hdr) 
			continue;

		if (p_hdr->p_type != PT_DYNAMIC)
			continue;

		//
		// Shared libraries may be relatively offset. 
		// This field effectively represents the module base address.
		//
		// added by sinister 3350124@mail.qq.com
		// 2021.1.6
		//

		module_base_address = (ElfW(Addr) *)((unsigned long)e_hdr);
		shared_object_dynamic_segment = (ElfW(Dyn) *)((unsigned long)e_hdr + p_hdr->p_vaddr);
		if (shared_object_dynamic_segment) {
#ifdef DEBUG
			fprintf_nouselib(2, "dynamic segment 0x%x\n", (unsigned long)shared_object_dynamic_segment);
#endif
			break;
		}

	}

	rt = 0;

	return rt;
}

/**
*
* @desc Enumerate process shared libraries, get link_map directly from GOT [1] 
*	without relying on libc functions
*
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.13
*
*/

void display_shared_librarys(void)
{
	dl_iterate_phdr(elf_process_dynamic_callback, NULL);
	elf_process_segment();

	if (nouselib)
		fprintf_nouselib(STDERR_FILENO, "\nEnumeration of shared librarys:\n");
	else
		fprintf(stderr, "\nEnumeration of shared librarys:\n");
	
	while (lm != NULL) {
		if (nouselib)
			fprintf_nouselib(STDERR_FILENO, "%p %s\n", (void *)lm->l_addr, lm->l_name);
		else
			fprintf(stderr, "%p %s\n", (void *)lm->l_addr, lm->l_name);

		lm = lm->l_next;
	}
}

static inline int within_segment(void *address, void *start_address, void *end_address)
{
	return ((void *)address >= start_address && (void *)address < end_address);
}

/**
*
* @desc The module name of the area where the address is located is obtained directly through "/proc".
*	The purpose of not using link_map is to consider the compatibility of different glibc versions.
*
* @param [IN] symbol address 
* @param [OUT] name of the module or process where the address area is located
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.21
*
*/

int _dlname_from_segment_address(void *address, char *object_path)
{
	FILE *fp;
	char line[128];
	int found = 0;

	void *start;
	void *end;

	char segment_features[32] = {0};
	char name[256] = {0};

	if (!address || !object_path) {
		return -1;
	}


	fp = fopen("/proc/self/maps", "r");
	if (!fp) {
		return -1;
	}

	strcpy(segment_features, "%p-%p %*s %*x %*x:%*x %*u %s");

	while (!found && fgets(line, sizeof(line), fp)) {

		if (3 != sscanf(line, segment_features,
				&start, &end, name))
			continue;

		if (!within_segment(address, start, end)) 
			continue;

		strcpy(object_path, name);
		
#ifdef DEBUG
		fprintf(stdout, "0x%lx-0x%lx %s\n", (uint64_t)start, (uint64_t)end, name);
#endif
		found = true;
	}

	fclose(fp);
	return !found;
}

/**
*
* @desc Directly use system call to read file.
*
* @param [IN] procfs path 
* @param [OUT] Specifies all the contents of the file
* 
* @retval file size 
*
* @NOTES: When the 'maps_buf' parameter is NULL, only the file size is returned. 
* 	  for 'procfs', the 'stat' syscall cannot return the file size.
*
* @author sinister 3350124@mail.qq.com
* @date 2021.01.03
*
*/

int syscall_read_file(const char *procpath, char *maps_buf)
{
	char buf[1024] = {0};
	int pos = 0;
	unsigned long size = 0;

	int fd;

	fd = _x64_open(procpath, O_RDONLY, 0644);
	if (fd < 0) {
		return -1;
	}
	
	do {
		size = _x64_read(fd, buf, sizeof(buf));
		if (size < 0) {
			pos = -2;
			break;
		}

		if (size == 0)
			break;
	
		if (maps_buf)	
			__copy_memory(maps_buf + pos, buf, size);
		pos = pos + size;

	} while(true);
	
	_x64_close(fd);

	return pos;
}

/**
*
* @desc Directly use system call to enumerate directory
*
* @param [IN] directory file descriptor 
* @param [IN] The callback function filters the specific content
* @param [IN] callback function params
*
* @author sinister 3350124@mail.qq.com
* @date 2021.01.18
*
*/

int syscall_enum_number_dir(int fd, int (*callback)(const char *name, void *data), void *data)
{
	struct linux_dirent *dirp = NULL;
	char buf[1024] = {0};
	int nread; int bpos;
	char d_type;
	int rt = 0; int rc = 0;
	int count = 0;

	if (!callback)
		return -1;

	for (;;) {
		nread = _x64_getdents(fd, (struct linux_dirent *)buf, 1024);
		if (nread == -1) {
			rt = nread;
			break;
		}

		if (nread == 0)
			break;

		for (bpos = 0; bpos < nread; bpos += dirp->d_reclen) {
			dirp = (struct linux_dirent *)(buf + bpos);
			if (!dirp)
				continue;

			d_type = *(buf + bpos + dirp->d_reclen - 1);
			if (d_type == DT_DIR) {
				if (dirp->d_name[0] == '.')
					continue;

				if (dirp->d_name[1] == '.')
					continue;

				//
				// Here we only deal with the directory of numeric type, 
				// which is 'PID' for 'procfs'
				//
				// 2021.01.10 added by sinister E-mail:3350124@mail.qq.com
				//

				if (-1 == __string_digit(dirp->d_name))
					continue;

				rc = callback(dirp->d_name, data);
				if (true == rc) {
					count ++;
				}
			}
		}
	}
	
	if (count > 0)
		rt = count;
	return rt;
}

/**
*
* @desc Directly use system call to enumerate directory
*
* @param [IN] directory file descriptor 
* @param [IN] The callback function filters the specific content
* @param [IN] callback function params
*
* @author sinister 3350124@mail.qq.com
* @date 2021.01.18
*
*/


/**
*
* @desc The module name of the area where the address is located is obtained directly through "/proc".
*	The purpose of not using link_map is to consider the compatibility of different glibc versions.
*
* @desc Do not use system library functions, is to prevent being bypassed.
*
* @param [IN] symbol address 
* @param [OUT] name of the module or process where the address area is located
*
* @author sinister 3350124@mail.qq.com
* @date 2020.01.05
*
*/

int dlname_from_segment_nouselib(void *address, char *object_path)
{
	char *maps_buf;
	char *newline;
	char *line_sep = "\n";
	char *line_token;

	int found = 0;
	int rt = 0;
	char *str, *endptr;

	char *modname;
	unsigned long start_address;
	unsigned long end_address;

	if (!address || !object_path) {
		rt = -1;	
		goto err;
	}	
		

	maps_buf = (char *)malloc(BUFFER_SIZE);
	if (!maps_buf) {
		rt = -2;
		goto err;
	}

	memset(maps_buf, 0, BUFFER_SIZE);

	rt = syscall_read_file("/proc/self/maps", maps_buf);
	if (rt < 0) {
		rt = -3;
		goto err;
	}

	newline = maps_buf;

	while (!found && 
		(line_token = __string_sep(&newline, line_sep))) {

		if (!line_token)
			continue;

		modname = __string_chr(line_token, '/');
		str = __string_chr(line_token, '-'); 
		if (!str)
			continue;

		start_address = __string_toul(line_token, &endptr, 16);
		end_address = __string_toul(str + 1, &endptr, 16);

		if (!within_segment(address, 
				(void *)start_address, 
				(void *)end_address))

			continue;
		

#ifdef DEBUG
		fprintf(stdout, "0x%lx-0x%lx %s\n", start_address, end_address, modname);
#endif
		__copy_string(object_path, modname);
		
		found = true;
	}

	rt = found;
	free(maps_buf);
	maps_buf = NULL;

err:
	return rt;
}

/**
*
* @desc Get module name mapping address is located is obtained directly through "/proc".
*	The purpose of not using link_map is to consider the compatibility of different glibc versions.
*
* @desc Do not use system library functions, is to prevent being bypassed.
*
* @param [IN] libc name, 'NULL' is to get the current process mapping base address
* @param [OUT] start address 
*
* @author sinister 3350124@mail.qq.com
* @date 2020.01.07
*
*/

int dladdress_from_segment_nouselib(const char *dlname, unsigned long *address)
{
	char *maps_buf;
	char *newline;
	char *line_sep = "\n";
	char *line_token;
	char *endptr;

	int found = 0;
	int rt = 0;

	char *modname;

	if (!address) {
		rt = -1;	
		goto err;
	}	
		

	maps_buf = (char *)malloc(BUFFER_SIZE);
	if (!maps_buf) {
		rt = -2;
		goto err;
	}

	memset(maps_buf, 0, BUFFER_SIZE);

	rt = syscall_read_file("/proc/self/maps", maps_buf);
	if (rt < 0) {
		rt = -3;
		goto err;
	}

	newline = maps_buf;

	while (!found && 
		(line_token = __string_sep(&newline, line_sep))) {

		if (!line_token)
			continue;

		if (!dlname) {
			*address = __string_toul(line_token, &endptr, 16);
			found = true;
			break;

		} else {
			modname = __string_chr(line_token, '/');
			if (!modname)
				continue;

			if (!__match_strstr(modname, dlname))
				continue;

			*address = __string_toul(line_token, &endptr, 16);
			found = true;
			break;
		}

#ifdef DEBUG
		fprintf(stdout, "0x%lx %s\n", *address, modname);
#endif
		
	}

	rt = found;
	free(maps_buf);
	maps_buf = NULL;

err:
	return rt;
}


int fill_iterate_callback(struct dl_phdr_info *dpi, size_t size, void *data)
{
	return 0;
}

/**
*
* @desc Because of the lazy bind, all the symbols that need to be detected are called once, 
*	so that the relevant symbolic address can be found in GOT entry. 
*	if there is a PRELOAD hook, it will find the address after the hook, not the original address.
*	
*
* @author sinister 3350124@mail.qq.com
* @date 2019.09.19
*
*/

void call_symbol_fill_got(void)
{
	FILE *fp = NULL;
	struct stat statbuf = {0};
	struct stat64 stat64buf = {0};
	const char *dirname = "/tmp/";
	const char *filename = "/tmp/tmpfile.xxx";
	char *const argv[1];
	char buf[] = "fill"; 
	int rc, fd;

	rc = access(filename, F_OK);
	rc = stat(filename, &statbuf);
	rc = __xstat(0, filename, &statbuf);
	rc = stat64(filename, &stat64buf);
	rc = __xstat64(0, filename, &stat64buf);
	rc = lstat(filename, &statbuf);
	rc = __lxstat(0, filename, &statbuf);
	rc = lstat64(filename, &stat64buf);
	rc = __lxstat64(0, filename, &stat64buf);

	fd = open(filename, O_RDWR | O_CREAT);
	fd = open64(filename, O_RDWR | O_CREAT);
	fd = openat(AT_FDCWD, filename, O_RDWR | O_CREAT);
	fd = openat64(AT_FDCWD, filename, O_RDWR | O_CREAT);
	fp = fopen(filename, "rb");
	fp = fopen64(filename, "rb");
	rc = write(fd, buf, sizeof(buf)); 
	rc = read(fd, buf, sizeof(buf));
	rc = fstat(fd, &statbuf);
	rc = fstat64(fd, &stat64buf);	

	if (fp)
		fclose(fp);

	if (fd > 0)
		close(fd);

	extern char __executable_start[]; 
	rc = mprotect((void *)((unsigned long)__executable_start & ~(getpagesize() - 1)), 
				getpagesize(),
				PROT_READ|PROT_WRITE|PROT_EXEC
				);

	void *map_address;
	map_address = mmap((void *)__executable_start, getpagesize(), 
				PROT_READ, MAP_SHARED, 0, 0);
	map_address = mmap64((void *)__executable_start, getpagesize(), 
				PROT_READ, MAP_SHARED, 0, 0);
	if (map_address)	
		map_address = NULL;


	rc = chmod(filename, 777);
	rc = chown(filename, 74, 74);
	rc = rename(filename, filename);
	rc = renameat(AT_FDCWD, filename, AT_FDCWD, filename);
	rc = execve(filename, argv, NULL);
	rc = unlink(filename);
	rc = unlinkat(AT_FDCWD, filename, 0);
	rc = rmdir(filename);
	rc = readlink(filename, buf, sizeof(buf));

	DIR *dp;
	dp = opendir(dirname);
	if (dp) {
 		struct dirent *de = readdir(dp);
		struct dirent64 *de64 = readdir64(dp);
		de = de;
		de64 = de64;
		closedir(dp);
	}

	int s;
	s = socket(AF_INET, SOCK_DGRAM, 0);
	struct sockaddr sa;
	connect(s, &sa, sizeof(sa));
	socklen_t addrlen;
	accept(s, &sa, &addrlen);

	pid_t pid;
	pid = getpid();
	pid = syscall(SYS_getpid);
	if (pid < 0)
		pid = -1;

	ptrace(PTRACE_TRACEME, 0, NULL, NULL);

	void *handle;
	void *address;
	Dl_info dli;

	handle = dlopen(NULL, RTLD_LAZY);
	handle = dlmopen(LM_ID_BASE, NULL, RTLD_LAZY);
	if (handle) {
		dlclose(handle);
	}
	address = dlsym(RTLD_NEXT, "open");
	address = dlvsym(RTLD_NEXT, "open", "GLIBC_2.2.5");  

	rc = dladdr(address, &dli);
	rc = dladdr1(address, &dli, NULL, RTLD_DL_LINKMAP);

	dl_iterate_phdr(fill_iterate_callback, NULL);

	if (get_glibc_version() > (unsigned int)2025)
		goto end;

	if (__libc_dlopen_mode) {
		handle = (void *)__libc_dlopen_mode("libdl.so.2", RTLD_LOCAL | RTLD_NOW);
	}

	if (__libc_dlsym && handle)
		address = __libc_dlsym(handle, "dlsym");

	if (__libc_dlclose && handle)
		__libc_dlclose(handle);



	if (_dl_sym)
		address = _dl_sym(RTLD_NEXT, "open", call_symbol_fill_got);
	if (_dl_vsym)
		address = _dl_vsym(RTLD_NEXT, "open", "GLIBC_2.2.5", call_symbol_fill_got);

	if(_dl_addr)
		rc = _dl_addr(address, &dli,(void *) NULL, (void *)NULL);

end:
	if (rc < 0)
		rc = -1;
}

/**
*
* @desc read '/etc/ld.so.preload' file content, use syscall directly
*
* @author sinister 3350124@mail.qq.com
* @date 2021.01.13
*
*/

int print_preload_content(void)
{
	struct stat statbuf;
	char *file_buffer;
	const char preload_path[] = "/etc/ld.so.preload";
	int rt = 0;

	rt = _x64_stat(preload_path, &statbuf);
	if (rt < 0)
		return rt;

	if (statbuf.st_size <= 0)
		return rt;

	file_buffer = (char *)malloc(BUFFER_SIZE);
	if (!file_buffer) {
		rt = -1;
		return rt;
	}

	memset(file_buffer, 0, BUFFER_SIZE);

	__set_memory(file_buffer, 0, getpagesize());

	rt = syscall_read_file(preload_path, file_buffer);
	if (rt < 0) {
		return rt;
	}

	fprintf_nouselib(2, "\n/etc/ld.so.preload\n\n%s\n", file_buffer);

	free(file_buffer);
	file_buffer = NULL;

	return rt;	
}

/**
*
* @desc Empty '/etc/ld.so.preload' file content, use syscall directly
*
* @author sinister 3350124@mail.qq.com
* @date 2021.01.13
*
*/

int syscall_erase_preload_content(void)
{
	int fd;
	int rt = 0;

	fd = _x64_open("/etc/ld.so.preload", O_RDONLY | O_TRUNC, 0644);
	if (fd < 0) {
		return fd;
	}

	return rt;
}

/**
*
* @desc Detect whether the environment variable of the specified 'PID' has 'LD_PRELOAD'
*
* @param [IN] /proc/PID
* @param [IN] As a callback function, this parameter is null
*
* @retval  0  Not found
*          1  Found LD_PRELOAD
*         -1  param error
*         -2  memory alloc error
*         -3  Failed to read the PID directory specified by 'procfs'
*
* @NOTES: In the case of non root users, it is possible that the failure is caused by permission problems
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

int detect_pid_preload(const char *pid_dir, void *data)
{
	const char *procdir = "/proc/";
	const char *envdir  = "/environ";
	const char *exe = "/exe";
	char exepath[512] = {0};
	char exebuf[1024] = {0};
	char envpath[512] = {0};	
	char *env_buf = NULL;
	char line_token[2048] = {0};
	char *ptr;
	int pos = 0;

	int found = 0;
	int rt = 0; int rc = -1;

	if (!pid_dir)
		return -1;

	env_buf = (char *)malloc(BUFFER_SIZE);
	if (!env_buf) {
		rt = -2;
		goto err;
	}

	__copy_string(envpath, procdir);
	__append_string(envpath, pid_dir);
	__append_string(envpath, envdir);

	__copy_string(exepath, procdir);
	__append_string(exepath, pid_dir);
	__append_string(exepath, exe);


	rt = syscall_read_file(envpath, env_buf);
	if (rt < 0) {
		rt = -3;
		goto err;
	}

	do {
		ptr = __copy_string(line_token, &env_buf[pos]);
		pos = pos + __length_string(ptr) + 1;

		if (!__match_strstr(line_token, "LD_PRELOAD="))
			continue;
	
		rc = _x64_readlink(exepath, exebuf, 1024);
		if (rc > 0)
			fprintf_nouselib(2, "Found %s(%s) %s\n", exebuf, pid_dir, line_token);
		else
			fprintf_nouselib(2, "Found %s %s\n", pid_dir, line_token);

		found = true;
		break;
		
	} while(pos <= rt);

	rt = found;

	if (env_buf) {
		free(env_buf);
		env_buf = NULL;
	}
err:
	return rt;
}

/**
*
* @desc Detects whether the specified shared library is loaded by the specified PID
*
* @param [IN] /proc/PID
* @param [IN] The name of the shared library to look for
*
* @retval  0  Not found
*          1  Found LD_PRELOAD
*         -1  param error
*         -2  memory alloc error
*         -3  Failed to read the PID directory specified by 'procfs'
*
* @NOTES: In the case of non root users, it is possible that the failure is caused by permission problems
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

int detect_pid_soname(const char *pid_dir, void *data)
{
	const char *procdir = "/proc/";
	const char *mapsdir  = "/maps";
	const char *exe = "/exe";
	char exepath[512] = {0};
	char exebuf[1024] = {0};
	char mapspath[512] = {0};	
	char *maps_buf = NULL;

	char *newline;
	char *line_sep = "\n";
	char *line_token;

	int rt = 0; int rc = 0;
	int found = 0;
	unsigned long size = 0;

	char *modname;
	const char *dlname = (const char *)data;

	if (!pid_dir || !dlname)
		return -1;

	__copy_string(mapspath, procdir);
	__append_string(mapspath, pid_dir);
	__append_string(mapspath, mapsdir);

	size = syscall_read_file(mapspath, NULL);
	if (size < 0) {
		rt = -3;
		goto err;
	}

	maps_buf = (char *)malloc(size + sizeof(char *));
	if (!maps_buf) {
		rt = -2;
		goto err;
	}

	size = syscall_read_file(mapspath, maps_buf);
	if (size < 0) {
		rt = -3;
		goto err;
	}

	__copy_string(exepath, procdir);
	__append_string(exepath, pid_dir);
	__append_string(exepath, exe);

	newline = maps_buf;

	while (!found && 
		(line_token = __string_sep(&newline, line_sep))) {

		if (!line_token)
			continue;

		modname = __string_chr(line_token, '/');
		if (!modname)
			continue;

		if (!__match_strstr(modname, dlname))
				continue;

		rc = _x64_readlink(exepath, exebuf, 1024);
		if (rc > 0)
			fprintf_nouselib(2, "Found %s(%s) %s\n", exebuf, pid_dir, modname);
		else
			fprintf_nouselib(2, "Found %s %s\n", pid_dir, modname);

		found = true;
	}

	rt = found;
	free(maps_buf);
	maps_buf = NULL;

err:
	return rt;
}

/**
*
* @desc Adds the specified filename to the GLIBC list.
*
* @param [IN] The name of the file to add to the GLIBC list.
*
* @retval  None
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

void add_to_glibc_list(const char *filename)
{
	if (!filename)
		return;

	FileNode *new_node = (FileNode *)malloc(sizeof(FileNode));
	if (!new_node) 
		return;

	pthread_mutex_lock(&glibc_list_lock);

	new_node->filename = strdup(filename);
	if (!new_node->filename) {
		free(new_node);
		new_node = NULL;
		goto end;
	}

	new_node->next = glibc_list;
	glibc_list = new_node;

end:
	pthread_mutex_unlock(&glibc_list_lock);
	return;
}

/**
*
* @desc Adds the specified filename to the syscall list.
*
* @param [IN] The name of the file to add to the syscall list.
*
* @retval  None
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

void add_to_syscall_list(const char *filename)
{
	if (!filename)
		return;

	FileNode *new_node = (FileNode *)malloc(sizeof(FileNode));
	if (!new_node) 
		return;

	pthread_mutex_lock(&syscall_list_lock);

	new_node->filename = strdup(filename);
	if (!new_node->filename) {
		free(new_node);
		new_node = NULL;
		goto end;
	}

	new_node->next = syscall_list;
	syscall_list = new_node;

	pthread_mutex_unlock(&syscall_list_lock);
end:

	return;
}

/**
*
* @desc Free the GLIBC list 
*
* @param [IN] None 
*
* @retval  None
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

void free_glibc_list(void)
{
	pthread_mutex_lock(&glibc_list_lock);

	FileNode *node = glibc_list;

	while (node) {

		FileNode *temp = node;
		node = node->next;
		free(temp->filename);
		free(temp);
	}

	glibc_list = NULL;

	pthread_mutex_unlock(&glibc_list_lock);
}

/**
*
* @desc Free the syscall list 
*
* @param [IN] None 
*
* @retval  None
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

void free_syscall_list(void)
{
	pthread_mutex_lock(&syscall_list_lock);

	FileNode *node = syscall_list;

	while (node) {

		FileNode *temp = node;
		node = node->next;
		free(temp->filename);
		free(temp);
	}

	syscall_list = NULL;

	pthread_mutex_unlock(&syscall_list_lock);
}

/**
*
* @desc show the syscall list 
*
* @param [IN] None 
*
* @retval Returns the total number of files
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

int show_in_syscall_list(void)
{
	int found = 0;

	pthread_mutex_lock(&syscall_list_lock);

	FileNode *node = syscall_list;

	while (node) {
		found ++;
		fprintf(stdout, "[syscall_list ->] %s\n", node->filename);
		node = node->next;
	}

	pthread_mutex_unlock(&syscall_list_lock);

	return found; 
}

/**
*
* @desc show the GLIBC list 
*
* @param [IN] None 
*
* @retval Returns the total number of files
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

int show_in_glibc_list(void)
{
	int found = 0;

	pthread_mutex_lock(&glibc_list_lock);

	FileNode *node = glibc_list;

	while (node) {
		found ++;
		fprintf(stdout, "[glibc_list ->] %s\n", node->filename);
		node = node->next;
	}

	pthread_mutex_unlock(&glibc_list_lock);

	return found; 
}


/**
*
* @desc Create a hash table with a specified number of buckets.
*
* @param [IN] size    The number of buckets for the hash table. Must be greater than 0.
*
* @retval Returns a pointer to the created HashTable on success, or NULL on failure.
*         If the size is less than or equal to 0, or any allocation fails, NULL is returned.
*
*
* @author sinister 3350124@mail.qq.com
* @date 2022.9.15
*
*/

HashTable *create_hash_table(int size)
{
	HashTable *table = NULL;

	if (size <= 0)
		goto end;

        table = malloc(sizeof(HashTable));
	if (!table) {
		goto end;
	}

        table->buckets = calloc(size, sizeof(HashNode *));
	if (!table->buckets) {
		free(table);
		table = NULL;
		goto end;
	}

        table->size = size;
        table->locks = malloc(size * sizeof(pthread_mutex_t));
	if (!table->locks) {
		free(table->buckets);
		table->buckets = NULL;
		free(table);
		table = NULL;
		goto end;
	}

        for (int i = 0; i < size; i++) {
                pthread_mutex_init(&table->locks[i], NULL);
        }

end:
        return table;
}

/**
*
* @desc Insert a filename into the hash table.
*
* @param [IN] table     A pointer to the HashTable in which the filename will be inserted.
* @param [IN] filename  The filename to be inserted into the hash table.
*
* @retval Returns 1 if the insertion is successful; otherwise, returns -1 on failure due to
*         invalid parameters or memory allocation failures.
*
* @author sinister 3350124@mail.qq.com
* @date 2022.9.15
*
*/

int insert_to_hash_table(HashTable *table, const char *filename)
{
	int rt = -1;

	if (!table || !filename)
		return rt;

        unsigned int index = hash_function(filename, table->size);
	if (index < 0) 
		return rt;
        
        pthread_mutex_lock(&table->locks[index]);

        HashNode *new_node = malloc(sizeof(HashNode));
	if (!new_node)
		goto end;

	new_node->filename = strdup(filename);
	if (!new_node->filename) {
		free(new_node);
		new_node = NULL;
		goto end;
	}

	new_node->next = table->buckets[index];
	table->buckets[index] = new_node;
	rt = 1;

end:
        pthread_mutex_unlock(&table->locks[index]);

	return rt;
}


/**
*
* @desc Search for a filename in the hash table.
*
* @param [IN] table     A pointer to the HashTable where the filename will be searched.
* @param [IN] filename  The filename to look for in the hash table.
*
* @retval Returns 1 if the filename is found in the hash table.
*         Returns 0 if the filename is not found.
*         Returns -1 on failure due to invalid parameters.
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

int find_in_hash_table(HashTable *table, const char *filename)
{
	if (!table || !filename)
		return -1;

        unsigned int index = hash_function(filename, table->size);
        
        pthread_mutex_lock(&table->locks[index]);

        HashNode *node = table->buckets[index];

        while (node) {
                if (strcmp(node->filename, filename) == 0) {
                        pthread_mutex_unlock(&table->locks[index]);
                        return 1; 
                }
                node = node->next;
        }

        pthread_mutex_unlock(&table->locks[index]);

        return 0; 
}

/**
*
* @desc Free all memory associated with the hash table and its contents.
*
* @param [IN] table     A pointer to the HashTable to be freed. If NULL, the function does nothing.
*
* @retval None
*
* @author sinister 3350124@mail.qq.com
* @date 2022.9.15
*
*/

void free_hash_table(HashTable *table)
{
	if (!table)
		return;

        for (int i = 0; i < table->size; i++) {
                pthread_mutex_lock(&table->locks[i]);

                HashNode *node = table->buckets[i];
                while (node) {
                        HashNode *temp = node;
                        node = node->next;
                        free(temp->filename);
                        free(temp);
                }

                pthread_mutex_unlock(&table->locks[i]);
        }

        for (int i = 0; i < table->size; i++) {
                pthread_mutex_destroy(&table->locks[i]);
        }

        free(table->locks);
	table->locks = NULL;
        free(table->buckets);
	table->buckets = NULL;
        free(table);
	table = NULL;
}

/**
*
* @desc Dynamically displays the scanning status of a given path in the console.
*       It updates the console line with a formatted message indicating the current scan type and path.
*
* @param [IN] path The path to display during scanning. This should be a null-terminated string.
* @param [IN] flags An integer representing the type of scan. Possible values:
*                   - GLIBC: Indicates a GLIBC scan.
*                   - SYSCALL: Indicates a syscall scan.
*                   - MATCH_LIST: Indicates a generic detection process.
*
* @retval None
*
* @NOTES: The function assumes `flags` is a valid value corresponding to one of the predefined scan types.
*         If `path` is NULL, the function will return immediately without any display action.
*         The path is truncated to a maximum of 100 characters for display purposes.
*         The console output uses ANSI escape codes to overwrite the current line for dynamic display.
*         Ensure your terminal supports ANSI escape sequences for proper functioning.
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

void scaning_display(const char *path, int flags)
{
	if (!path)
		return;

	char display_path[125] = {0};

	snprintf(display_path, sizeof(display_path), "%.100s", path);

    	fprintf(stdout, "\r\033[2K");

	if (flags == GLIBC)
		fprintf(stdout, "GLIBC Scaning...%-100s", display_path);
	else if (flags == SYSCALL)
		fprintf(stdout, "syscall Scaning...%-100s", display_path);
	else if (flags == MATCH_LIST)
		fprintf(stdout, "Detecting...%-100s", display_path);

	fflush(stdout);  
}

/**
*
* @desc Compares filenames between the GLIBC list and the syscall list. 
*	Displays each syscall filename and indicates if it is found in the GLIBC list, 
*	and returns the count of hidden files not found in the GLIBC list.
*
* @param None
*
* @retval int The number of hidden files found that are not present in the GLIBC list.
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

#ifdef _DISABLE_CODE

int match_glibc_syscall_list(void)
{
	int found = 0;
	int files_found = 0;
	int hidden_found = 0;

        pthread_mutex_lock(&syscall_list_lock);

        for (FileNode *syscall_node = syscall_list; syscall_node; syscall_node = syscall_node->next) {

                pthread_mutex_lock(&glibc_list_lock);

                for (FileNode *glibc_node = glibc_list; glibc_node; glibc_node = glibc_node->next) {
                        if (__match_string(syscall_node->filename, glibc_node->filename)) {
                                found = 1;
                                break;
                        }
                }

                pthread_mutex_unlock(&glibc_list_lock);

                if (found) {
			files_found ++;
			scaning_display(syscall_node->filename, MATCH_LIST);
                } else {
			hidden_found ++;
                        fprintf(stdout, "\n\033[1;31m[HIDDEN FILE]\033[0m %s\n", syscall_node->filename);
                }
        }

        pthread_mutex_unlock(&syscall_list_lock);

        return files_found + hidden_found;
}

#endif


/**
*
* @desc Match filenames from the glibc list with those in the syscall list using a hash table.
*
* @param [IN] None
*
* @retval Returns the total number of files processed (matched and hidden).
*         Returns -1 if there is an error during hash table creation or insertion.
*
* @author sinister 3350124@mail.qq.com
* @date 2022.9.15
* 
*/

int match_glibc_syscall_hashtable(void)
{
	int rt = -1;
        int files_found = 0;
        int hidden_found = 0;
        int hash_table_size = 1024;

        HashTable *hash_table = create_hash_table(hash_table_size);
	if (!hash_table)
		return rt;

        pthread_mutex_lock(&glibc_list_lock);

        for (FileNode *glibc_node = glibc_list; glibc_node; glibc_node = glibc_node->next) {
                rt = insert_to_hash_table(hash_table, glibc_node->filename);
		if (!rt) {
        		pthread_mutex_unlock(&glibc_list_lock);
			goto end; 
		}
        }

        pthread_mutex_unlock(&glibc_list_lock);

        pthread_mutex_lock(&syscall_list_lock);

        for (FileNode *syscall_node = syscall_list; syscall_node; syscall_node = syscall_node->next) {

                if (find_in_hash_table(hash_table, syscall_node->filename)) {
                        files_found ++;
                        scaning_display(syscall_node->filename, MATCH_LIST);
                } else {
                        hidden_found++;
                        fprintf(stdout, "\n\033[1;31m[HIDDEN FILE]\033[0m %s\n", syscall_node->filename);
                }
        }

        pthread_mutex_unlock(&syscall_list_lock);

end:
        free_hash_table(hash_table);
	hash_table = NULL;

        return files_found + hidden_found;
}

/**
*
* @desc Recursively reads the directory specified by `dir_path`, adding each file and subdirectory
*       path to the GLIBC list. It displays the current scanning path dynamically.
*
* @param [IN] dir_path The path of the directory to scan. Must be a valid, accessible directory path.
*
* @retval None
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

void glibc_dir_list(const char *dir_path)
{
        DIR *dir = opendir(dir_path);
        if (!dir) {
                perror("opendir");
                return;
        }

        struct dirent *entry;
        char original_path[PATH_MAX] = {0};
        char current_path[PATH_MAX] = {0};

        if (!getcwd(original_path, sizeof(original_path)))
                goto close_dir;

        if (0 != chdir(dir_path))
                goto close_dir;

        if (!getcwd(current_path, sizeof(current_path)))
                goto restore_dir;


        while ((entry = readdir(dir)) != NULL) {

                if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                    continue;

                struct stat st;
                char full_path[PATH_MAX] = {0};

                if (lstat(entry->d_name, &st) == 0) {

			int ret = snprintf(full_path, sizeof(full_path), "%s/%s", current_path, entry->d_name);
			if (ret >= sizeof(full_path)) {
				fprintf(stderr, "Path too long %s/%s\n", current_path, entry->d_name);
				goto restore_dir;
			}

			scaning_display(full_path, GLIBC);
			add_to_glibc_list(full_path);

			if (S_ISDIR(st.st_mode)) {
				glibc_dir_list(full_path);
			}
		}
	}

restore_dir:
        chdir(original_path);

close_dir:
        closedir(dir);
}


/**
*
* @desc Adds a given path to the syscall list while displaying the scanning process dynamically.
*
* @param [IN] path The file or directory path to be added to the syscall list. 
	      Expected to be a valid string.
* @param [IN] data Additional data passed by the caller, not used in this function.
*
* @retval int Always returns 0.
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

int call_to_syscall_list(const char *path, void *data)
{
	int rt = 0;

	if (path) {
	
		scaning_display(path, SYSCALL);
		add_to_syscall_list(path);
	}	

	return rt;
}


/**
*
* @desc Recursively enumerates all directories under the specified `base_path`, 
*	invoking a callback for each entry.
*       Manages directory traversal using low-level system calls for enhanced control.
*
* @param [IN] base_path The starting directory path to enumerate.
* @param [IN] callback A function pointer called for each entry found. 
* @param [IN] data Additional data to be passed to the callback function
*
* @retval int Returns 0 upon successful enumeration of all directories and entries, or -1 if an error occurs.
*
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

int syscall_enum_all_dir(const char *base_path, int (*callback)(const char *name, void *data), void *data)
{
        struct linux_dirent *dirp;
        char buf[1024];
        int fd, nread, bpos;

        // Save original path
        char original_path[PATH_MAX];
        if (!_x64_getcwd(original_path, sizeof(original_path)))
                return -1;

        fd = _x64_open(base_path, O_RDONLY | O_DIRECTORY, 0);
        if (fd == -1)
                return -1;

        if (_x64_chdir(base_path) == -1) {
            _x64_close(fd);
            return -1;
        }

        for (;;) {
                nread = _x64_getdents(fd, (struct linux_dirent *)buf, sizeof(buf));
                if (nread == -1) {
                    _x64_close(fd);
                    return -1;
                }

                if (nread == 0)
                    break;

                for (bpos = 0; bpos < nread; bpos += dirp->d_reclen) {
                    dirp = (struct linux_dirent *)(buf + bpos);
                    if (!dirp)
                        continue;

                    if (__match_string(dirp->d_name, ".") || __match_string(dirp->d_name, ".."))
                        continue;

                    char current_path[PATH_MAX];
                    if (!_x64_getcwd(current_path, sizeof(current_path))) {
                        _x64_close(fd);
                        return -1;
                    }

                    char full_path[PATH_MAX];
                    int ret = snprintf(full_path, sizeof(full_path), "%s/%s", current_path, dirp->d_name);
		    if (ret >= sizeof(full_path)) {
			 fprintf(stderr, "Path too long %s/%s\n", current_path, dirp->d_name);
			 goto restore_dir;
		    }

                    callback(full_path, data);

                    struct stat st;
                    if (_x64_lstat(full_path, &st) == 0) {
                        if (S_ISDIR(st.st_mode)) {
                            syscall_enum_all_dir(full_path, callback, data);
                        }
                    }
                }
        }

restore_dir:
        if (_x64_chdir(original_path) == -1) {
            return -1;
        }

        _x64_close(fd);
        return 0;
}


/**
*
* @desc Detect the 'LD_PRELOAD' environment variable of all processes
*
* @retval How many were found
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.18
*
*/

int detect_all_process_preload_env(void)
{
	int fd;
	int count = 0;

	fd = _x64_open("/proc", O_RDONLY | O_DIRECTORY, 0644);
	if (fd < 0) 
		return fd;

	count = syscall_enum_number_dir(fd, detect_pid_preload, NULL);
	_x64_close(fd);

	return count;
}

/**
*
* @desc Finds the specified shared library in all processes
*
* @retval How many were found
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.18
*
*/

int search_all_process_lib(const char *dlname)
{
	int fd;
	int count = 0;

	fd = _x64_open("/proc", O_RDONLY | O_DIRECTORY, 0644);
	if (fd < 0)
		return fd;

	count = syscall_enum_number_dir(fd, detect_pid_soname, (void *)dlname);
	_x64_close(fd);

	return count;
}

/**
*
* @desc Finds the specified shared library in all processes
*
* @retval How many were found
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.18
*
*/

int syscall_dir_list(const char *filepath)
{
	int count = 0;

	count = syscall_enum_all_dir(filepath, call_to_syscall_list, NULL);

	return count;
}



/**
*
* @desc Display symbols checklist 
*
* @author sinister 3350124@mail.qq.com
* @date 2021.01.03
*
*/

void show_checklist_table(void)
{
	const char **symbol_ptr;

	fprintf_nouselib(2, "\n");
        fprintf_nouselib(2, "internal hook structure checking:\n");
        fprintf_nouselib(2, "     dl_open_hook\n");
        fprintf_nouselib(2, "     dlfcn_hook\n");

	fprintf_nouselib(2, "\n");
        fprintf_nouselib(2, "dynamic loader symbols:\n");

	for (symbol_ptr = dl_symbol_table; 
		*symbol_ptr; 
		symbol_ptr ++) {
		
		fprintf_nouselib(2, "    %s\n", *symbol_ptr);
	}

	for (symbol_ptr = __libc_dl_symbol_table; 
		*symbol_ptr; 
		symbol_ptr ++) {

		fprintf_nouselib(2, "    %s\n", *symbol_ptr);

	}

	fprintf_nouselib(2, "\n");

	fprintf_nouselib(2, "system library symbols:\n");

	for (symbol_ptr = syslib_symbol_table; 
		*symbol_ptr; 
		symbol_ptr ++) {

		fprintf_nouselib(2, "    %s\n", *symbol_ptr);
	}

	fprintf_nouselib(2, "\n");

}

/**
*
* @desc Retrieves the version of the GNU C Library (GLIBC) installed on the system and returns it as an
*       unsigned integer, representing the major and minor version numbers in a single value.
*
* @param None
*
* @retval unsigned int The GLIBC version encoded as an integer in the format
*	  (major_version * 1000 + minor_version).
*      	  For example, GLIBC version 2.31 will be returned as 2031.
*
*
* @author sinister 3350124@mail.qq.com
* @date 2021.1.15
*
*/

unsigned int get_glibc_version()
{
	unsigned int major = 0, minor = 0;
	char version[16] = {0};

	confstr(_CS_GNU_LIBC_VERSION, version, sizeof(version));
	sscanf(version, "glibc %u.%u", &major, &minor);

	return major * 1000 + minor;
}

void detpl_help(void)
{
	fprintf_nouselib(STDOUT_FILENO, "\nDetecting PRELOAD malware...\nCopyright or GPL ? But who really cares\nversion 1.0\n");
	fprintf_nouselib(STDOUT_FILENO, "code by sinister E-mail:3350124@mail.qq.com\n\n");
	fprintf_nouselib(STDOUT_FILENO, "Usage: detpl [option]...\n\n");
	fprintf_nouselib(STDOUT_FILENO, "    --dlhook-check   Detecting internal 'dl_open_hook' & 'dlfcn_hook' hook structure\n");
	fprintf_nouselib(STDOUT_FILENO, "    --dlsym-check    Detecting dynamic loader function\n");
	fprintf_nouselib(STDOUT_FILENO, "    --syslib-check   Detecting system library function\n");
	fprintf_nouselib(STDOUT_FILENO, "    --procenv-check  Detecting '/proc/PID/environ' different LD_PRELOAD shared library\n");
	fprintf_nouselib(STDOUT_FILENO, "    --so-search      Search '/proc/PID/maps' find a specific shared library file\n");
	fprintf_nouselib(STDOUT_FILENO, "    --preload-file-check     Detecting '/etc/ld.so.preload' file content\n");
	fprintf_nouselib(STDOUT_FILENO, "    --preload-file-erase     Erase '/etc/ld.so.preload' file content\n");
	fprintf_nouselib(STDOUT_FILENO, "    --search-hidden-file     Search path finding PRELOAD hidden file\n");
	fprintf_nouselib(STDOUT_FILENO, "    --displib        Display loaded library name\n");
	fprintf_nouselib(STDOUT_FILENO, "    --all-check      Include all checkpoints\n");
	fprintf_nouselib(STDOUT_FILENO, "    --checklist      List detecting symbol table\n");
	fprintf_nouselib(STDOUT_FILENO, "\n        -nouselib Do not use system library functions, use 'syscall' directly\n\n");
	fprintf_nouselib(STDOUT_FILENO, "Examples:\n");
	fprintf_nouselib(STDOUT_FILENO, "        ./detpl --dlhook-check\n");
	fprintf_nouselib(STDOUT_FILENO, "        ./detpl --dlsym-check\n");
	fprintf_nouselib(STDOUT_FILENO, "        ./detpl --syslib-check\n");
	fprintf_nouselib(STDOUT_FILENO, "        ./detpl --dlsym-check -nouselib\n");
	fprintf_nouselib(STDOUT_FILENO, "        ./detpl --syslib-check -nouseib\n");
	fprintf_nouselib(STDOUT_FILENO, "        ./detpl --all-check -nouselib\n");
	fprintf_nouselib(STDOUT_FILENO, "        ./detpl --so-search libc-2.17.so\n");
	fprintf_nouselib(STDOUT_FILENO, "        ./detpl --search-hidden-file /usr\n\n");
	fprintf_nouselib(STDOUT_FILENO, "NOTES:\n" 
					"         --file-check, --file-erase, --procenv-check, --so-search\n"
					"         The default method is '-nouselib'\n\n" 
					"         This is a non-invasive Detect tool,it can be run under in normal users.\n"
					"         Run in a non 'root' environment,Due to permissions you can only Detecting\n"
                                        "         the current PRELOAD malware. Of course, if you are in the 'root' environment\n"
					"         you may get more information with higher permissions.\n");
	fprintf_nouselib(1, "\n\n");
}

void process_common_options(int argc, char **argv, int extra_arg_idx)
{
	if (argc > extra_arg_idx + 1 && 
			__match_string(argv[extra_arg_idx + 1], "-nouselib")) {
        	nouselib = true;
    	} else if (argc > extra_arg_idx + 1) {
        	detpl_help();
    	}
}

void handle_dlhook_check(int argc, char **argv)
{
	process_common_options(argc, argv, 1);
	int sym_count = dl_internal_hook_struct_check();

	if (sym_count > 0) {
		fprintf_nouselib(STDERR_FILENO, "\n\n!!! %d internal hook struct have been hooked !!!\n", sym_count);
	}
}

void handle_dlsym_check(int argc, char **argv)
{
	process_common_options(argc, argv, 1);

	int sym_count = dl_symbol_check();

	if (sym_count > 0) {
		fprintf_nouselib(STDERR_FILENO, "\n\n!!! %d dynamic loader symbols have been hooked !!!\n", sym_count);
	}
}

void handle_syslib_check(int argc, char **argv)
{
	process_common_options(argc, argv, 1);

	int sym_count = syslib_symbol_check();

	if (sym_count > 0) {
		fprintf_nouselib(STDERR_FILENO, "\n\n!!! %d dynamic loader symbols have been hooked !!!\n", sym_count);
	}
}

void handle_detect_all_process_preload_env(int argc, char **argv)
{
	int env_count = detect_all_process_preload_env();
	if (env_count > 0) {
		fprintf_nouselib(2, "\n!!! %d PRELOAD environ !!!\n", env_count);	
	}
}

void handle_search_all_process_lib(int argc, char **argv)
{
	int lib_count;

	if (__length_string(argv[2]) > 512) {
		fprintf_nouselib(STDERR_FILENO, "\nso name is too long!\n");	
		return;
	}

	fprintf_nouselib(STDERR_FILENO, "\n"); 
	
	lib_count = search_all_process_lib(argv[2]);
	if (lib_count > 0) {
		fprintf_nouselib(STDERR_FILENO, "\n!!! %d process loaded the shared library !!!\n", lib_count);	
	}
}

void handle_display_shared_librarys(int argc, char **argv)
{
	process_common_options(argc, argv, 1);

	display_shared_librarys();
}

void handle_print_preload_content(int argc, char **argv)
{
	process_common_options(argc, argv, 1);

	print_preload_content();
}

void handle_syscall_erase_preload_content(int argc, char **argv)
{
	process_common_options(argc, argv, 1);

	syscall_erase_preload_content();
}

void handle_all_check(int argc, char **argv)
{
	process_common_options(argc, argv, 1);
	fprintf_nouselib(STDOUT_FILENO, "\n");

	int sym_count = dl_internal_hook_struct_check();
	if (sym_count > 0) {
		fprintf_nouselib(STDERR_FILENO, "\n\n!!! %d internal hook struct have been hooked !!!\n", sym_count);	
	}

	fprintf_nouselib(STDOUT_FILENO, "\n");

	sym_count = dl_symbol_check();
	if (sym_count > 0) {
		fprintf_nouselib(STDERR_FILENO, "\n\n!!! %d dynamic loader symbols have been hooked !!!\n", sym_count);	
	}

	fprintf_nouselib(STDOUT_FILENO, "\n");

	sym_count = syslib_symbol_check();
	if (sym_count > 0) {
		fprintf_nouselib(STDERR_FILENO, "\n\n!!! %d system library symbols have been hooked !!!\n", sym_count);	
	}

	display_shared_librarys();

	fprintf_nouselib(STDOUT_FILENO, "\n");

	print_preload_content();

	fprintf_nouselib(STDERR_FILENO, "\n");

	int env_count = detect_all_process_preload_env();
	if (env_count > 0) {
		fprintf_nouselib(STDERR_FILENO, "\n!!! %d PRELOAD environ !!!\n", env_count);	
	}

	fprintf_nouselib(STDERR_FILENO, "\n");

}

void handle_search_hidden_file(int argc, char **argv)
{
	fprintf(stdout, 
		"\nScanning [%s] directory\nDetecting hidden files using LD_PRELOAD method, please wait...\n\n", 
		argv[2]
		);

	if (_x64_access(argv[2], F_OK) < 0) {
		fprintf(stdout, "No such file or directory\n");
		return ;
	}

	glibc_dir_list(argv[2]);
	syscall_dir_list(argv[2]);

#ifdef DISABLE_CODE
	int glibc_list_total = show_in_glibc_list();
	int syscall_list_total = show_in_syscall_list();
	fprintf(stdout, "glibc_list_total: [%d] syscall_list_total: [%d]\n", glibc_list_total, syscall_list_total);
#endif
	struct timeval start, end;
        long seconds, useconds;
        double elapsed_time;

        gettimeofday(&start, NULL);	

	int total_files = match_glibc_syscall_hashtable();

   	gettimeofday(&end, NULL);

        seconds  = end.tv_sec  - start.tv_sec;
        useconds = end.tv_usec - start.tv_usec;
        elapsed_time = seconds + useconds/1000000.0;

        printf("\n\nTotal files %d match time: %.6f second\n", total_files, elapsed_time);

	free_syscall_list();
	free_glibc_list();
}

void handle_show_checklist_table(int argc, char **argv)
{

	show_checklist_table();
}

void handle_args(int argc, char **argv)
{
	if (argc < 2) {
		detpl_help();
		return;
	}

	if (__match_string(argv[1], "--dlhook-check")) {
		handle_dlhook_check(argc, argv);
	} else if (__match_string(argv[1], "--dlsym-check")) {
		handle_dlsym_check(argc, argv);
	} else if (__match_string(argv[1], "--syslib-check")){
		handle_syslib_check(argc, argv);
	} else if (__match_string(argv[1], "--procenv-check")){
		handle_detect_all_process_preload_env(argc, argv);
	} else if (__match_string(argv[1], "--so-search")){
		handle_search_all_process_lib(argc, argv);
	} else if (__match_string(argv[1], "--displib")) {
		handle_display_shared_librarys(argc, argv);
	} else if (__match_string(argv[1], "--preload-file-check")) {
		handle_print_preload_content(argc, argv);
	} else if (__match_string(argv[1], "--preload-file-delete")) {
		handle_syscall_erase_preload_content(argc, argv);
	} else if (__match_string(argv[1], "--all-check")) {
		handle_all_check(argc, argv);
	} else if (__match_string(argv[1], "--search-hidden-file")) {
		handle_search_hidden_file(argc, argv);
	} else if (__match_string(argv[1], "--checklist")) {
		handle_show_checklist_table(argc, argv);
	} else {
		detpl_help();
	}

}


int main(int argc, char **argv)
{
	call_symbol_fill_got();
	process_dynamic_segment = NULL;
	shared_object_dynamic_segment = NULL;

	handle_args(argc, argv);
	
	fprintf_nouselib(STDOUT_FILENO, "\n");
	fprintf_nouselib(STDERR_FILENO, "\n");
	
	return 0;
}
